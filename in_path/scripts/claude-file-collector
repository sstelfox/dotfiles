#!/usr/bin/env python3

import os
import sys
import shutil
import tempfile
import subprocess
from pathlib import Path
from datetime import datetime
from typing import Optional, Tuple, List, Dict
import re

def is_git_repository() -> bool:
    try:
        subprocess.run(['git', 'rev-parse', '--is-inside-work-tree'],
                      stdout=subprocess.DEVNULL,
                      stderr=subprocess.DEVNULL,
                      check=True)
        return True
    except subprocess.CalledProcessError:
        return False

def get_repository_root() -> Optional[Path]:
    try:
        result = subprocess.run(['git', 'rev-parse', '--show-toplevel'],
                              capture_output=True,
                              text=True,
                              check=True)
        return Path(result.stdout.strip())
    except subprocess.CalledProcessError:
        return None

class GitignoreParser:
    def __init__(self, gitignore_file: Path):
        self.ignore_patterns = []

        if gitignore_file.exists():
            with open(gitignore_file, 'r') as f:
                for line in f:
                    line = line.strip()
                    if line and not line.startswith('#'):
                        pattern = self._convert_gitignore_to_regex(line)
                        self.ignore_patterns.append(re.compile(pattern))

    def _convert_gitignore_to_regex(self, pattern: str) -> str:
        pattern = pattern.replace('.', r'\.')
        pattern = pattern.replace('*', '.*')
        pattern = pattern.replace('?', '.')

        if pattern.endswith('/'):
            return f"(^|.*?/){pattern}.*$"
        elif pattern.startswith('/'):
            return f"^{pattern[1:]}.*$"
        elif '/' in pattern:
            return f"^{pattern}.*$"
        return f"(^|.*?/){pattern}($|/.*$)"

    def should_ignore(self, path: str) -> bool:
        if not self.ignore_patterns:
            return False

        path_str = str(path)
        return any(pattern.match(path_str) for pattern in self.ignore_patterns)

def get_cache_dir() -> Path:
    xdg_cache = os.environ.get('XDG_CACHE_HOME')
    if xdg_cache:
        base_dir = Path(xdg_cache)
    else:
        base_dir = Path.home() / '.cache'

    return base_dir / 'git-file-collector'

def copy_repository_files(extensions: set[str]) -> Tuple[Path, int, int]:
    """
    Copy files from git repository to a temporary directory.
    Returns (temp_dir_path, files_copied, files_ignored)
    """
    if not is_git_repository():
        print("Error: Not in a git repository", file=sys.stderr)
        sys.exit(1)

    repo_root = get_repository_root()
    if not repo_root:
        print("Error: Could not determine repository root", file=sys.stderr)
        sys.exit(1)

    # Setup temporary directory with meaningful name
    cache_dir = get_cache_dir()
    cache_dir.mkdir(parents=True, exist_ok=True)

    timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
    repo_name = repo_root.name
    temp_dir = cache_dir / f"{repo_name}_{timestamp}"
    temp_dir.mkdir()

    gitignore = GitignoreParser(repo_root / '.gitignore')
    files_copied = 0
    files_ignored = 0
    file_mappings: List[Dict[str, str]] = []

    for root, _, files in os.walk(repo_root):
        rel_root = Path(root).relative_to(repo_root)

        for file in files:
            file_path = Path(root) / file
            rel_path = file_path.relative_to(repo_root)

            if gitignore.should_ignore(str(rel_path)):
                files_ignored += 1
                continue

            if file_path.suffix.lower() in extensions:
                # Preserve directory structure
                target_path = temp_dir / rel_path
                target_path.parent.mkdir(parents=True, exist_ok=True)

                shutil.copy2(file_path, target_path)
                files_copied += 1

                file_mappings.append({
                    'new_file': str(target_path),
                    'original_path': str(rel_path)
                })

    with open(temp_dir / 'file_map.txt', 'w') as f:
        f.write(f"File Mapping Generated on: {datetime.now()}\n")
        f.write(f"Source Repository: {repo_root}\n")
        f.write("-" * 80 + "\n\n")

        for mapping in sorted(file_mappings, key=lambda x: x['original_path']):
            f.write(f"New location: {mapping['new_file']}\n")
            f.write(f"Original path: {mapping['original_path']}\n")
            f.write("-" * 40 + "\n")

    return temp_dir, files_copied, files_ignored

def main():
    extensions = {'.rs', '.md', '.toml', '.py', '.js', '.jsx', '.ts', '.tsx', '.cpp', '.h', '.c'}

    try:
        temp_dir, files_copied, files_ignored = copy_repository_files(extensions)
        print(f"\nFiles copied successfully!")
        print(f"Location: {temp_dir}")
        print(f"Files copied: {files_copied}")
        print(f"Files ignored: {files_ignored}")
        print(f"File mapping available in: {temp_dir/'file_map.txt'}")
    except Exception as e:
        print(f"Error: {str(e)}", file=sys.stderr)
        sys.exit(1)

if __name__ == '__main__':
    main()

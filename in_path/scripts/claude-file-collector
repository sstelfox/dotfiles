#!/usr/bin/env python

import os
import sys
import shutil
import tempfile
import subprocess
from pathlib import Path
from datetime import datetime
from typing import Optional, Tuple, List, Dict
import re

def is_git_repository() -> bool:
    try:
        subprocess.run(['git', 'rev-parse', '--is-inside-work-tree'],
                       stdout=subprocess.DEVNULL,
                       stderr=subprocess.DEVNULL,
                       check=True)
        return True
    except subprocess.CalledProcessError:
        return False

def get_repository_root() -> Optional[Path]:
    try:
        result = subprocess.run(['git', 'rev-parse', '--show-toplevel'],
                                capture_output=True,
                                text=True,
                                check=True)
        return Path(result.stdout.strip())
    except subprocess.CalledProcessError:
        return None

class GitignoreParser:
    def __init__(self, gitignore_file: Path):
        self.ignore_patterns = []

        if gitignore_file.exists():
            with open(gitignore_file, 'r') as f:
                for line in f:
                    line = line.strip()
                    if line and not line.startswith('#'):
                        pattern = self._convert_gitignore_to_regex(line)
                        self.ignore_patterns.append(re.compile(pattern))

    def _convert_gitignore_to_regex(self, pattern: str) -> str:
        pattern = pattern.replace('.', r'\.')
        pattern = pattern.replace('*', '.*')
        pattern = pattern.replace('?', '.')

        if pattern.endswith('/'):
            return f"(^|.*?/){pattern}.*$"
        elif pattern.startswith('/'):
            return f"^{pattern[1:]}.*$"
        elif '/' in pattern:
            return f"^{pattern}.*$"
        return f"(^|.*?/){pattern}($|/.*$)"

    def should_ignore(self, path: str) -> bool:
        if not self.ignore_patterns:
            return False

        path_str = str(path)
        return any(pattern.match(path_str) for pattern in self.ignore_patterns)

def get_cache_dir() -> Path:
    xdg_cache = os.environ.get('XDG_CACHE_HOME')
    if xdg_cache:
        base_dir = Path(xdg_cache)
    else:
        base_dir = Path.home() / '.cache'

    return base_dir / 'git-file-collector'

def get_unique_filename(target_dir: Path, base_name: str) -> Path:
    counter = 0
    name = Path(base_name)
    stem = name.stem
    suffix = name.suffix

    while True:
        if counter == 0:
            new_name = name
        else:
            new_name = Path(f"{stem}_{counter}{suffix}")

        full_path = target_dir / new_name
        if not full_path.exists():
            return new_name
        counter += 1

def copy_repository_files(extensions: set[str]) -> Tuple[Path, int, int]:
    """
    Copy files from git repository to a temporary directory, flattening the structure.
    Returns (temp_dir_path, files_copied, files_ignored)
    """
    if not is_git_repository():
        print("Error: Not in a git repository", file=sys.stderr)
        sys.exit(1)

    repo_root = get_repository_root()
    if not repo_root:
        print("Error: Could not determine repository root", file=sys.stderr)
        sys.exit(1)

    # Setup temporary directory with meaningful name
    cache_dir = get_cache_dir()
    cache_dir.mkdir(parents=True, exist_ok=True)

    timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
    repo_name = repo_root.name
    temp_dir = cache_dir / f"{repo_name}_{timestamp}"
    temp_dir.mkdir()

    gitignore = GitignoreParser(repo_root / '.gitignore')
    files_copied = 0
    files_ignored = 0
    file_mappings: List[Dict[str, str]] = []

    for root, _, files in os.walk(repo_root):
        rel_root = Path(root).relative_to(repo_root)

        for file in files:
            file_path = Path(root) / file
            rel_path = file_path.relative_to(repo_root)

            if gitignore.should_ignore(str(rel_path)):
                files_ignored += 1
                continue

            if file_path.suffix.lower() in extensions:
                unique_name = get_unique_filename(temp_dir, file)
                target_path = temp_dir / unique_name

                shutil.copy2(file_path, target_path)
                files_copied += 1

                file_mappings.append({
                    'new_file': str(unique_name),
                    'original_path': str(rel_path)
                })

    with open(temp_dir / 'file_map.txt', 'w') as f:
        f.write(f"File Mapping Generated on: {datetime.now()}\n")
        f.write(f"Source Repository: {repo_root.name}\n")
        f.write("-" * 80 + "\n\n")

        for mapping in sorted(file_mappings, key=lambda x: x['original_path']):
            f.write(f"New filename: {mapping['new_file']}\n")
            f.write(f"Original path: {mapping['original_path']}\n")
            f.write("-" * 40 + "\n")

    return temp_dir, files_copied, files_ignored

def main():
    #extensions = {'.rs', '.md', '.toml', '.py', '.js', '.jsx', '.ts', '.tsx', '.cpp', '.h', '.c', '.zig', '.rb', '.sh'}
    extensions = {'.rs', '.md', '.toml', '.js', '.html', '.css'}

    try:
        temp_dir, files_copied, files_ignored = copy_repository_files(extensions)
        print(f"\nFiles copied successfully!")
        print(f"Location: {temp_dir}")
        print(f"Files copied: {files_copied}")
        print(f"Files ignored: {files_ignored}")
        print(f"File mapping available in: {temp_dir/'file_map.txt'}")
    except Exception as e:
        print(f"Error: {str(e)}", file=sys.stderr)
        sys.exit(1)

if __name__ == '__main__':
    main()
